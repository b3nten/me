---
title: On the Increasing Unhappiness of JS Developers
date: 07/05/2024
---

The recent survey of the state of JavaScript has indicated that developers are becoming increasingly unhappy about modern Javascript frameworks. Why?

(Keep in mind this is only my *opinion*, and there is a fair amount of bias here due to my personal feelings about JS frameworks. Take this with a grain of salt.)

Modern front end frameworks have paradoxically shifted to the backend. Almost all development is focused on server-side rendering and initial page load performance with little development and innovation towards their main use-case: single page apps. For example, Next.js forces the root component of it's new App router to be a server component. Next, Nuxt, Sveltekit, Remix, Solid Start, and Qwik all default to server side rendering and require various configuration to disable.   Not only does the push towards SSR sacrifice leave local first and client based applications behind, but it often adds additional hoops for the developer to jump through if they wish to remain on the client. Remix recently released `clientLoaders` as a way to adopt framework features on the client, but this a somewhat rare development.

The push towards SSR is part of a larger trend in focusing on ecommerce at the expense of other genres of application. Framework authors have become obsessed with optimizing first-load performance - in React's case, going as far as removing the ability for components inside `<Suspense />` boundaries to load simultaneously. This (thankfully reverted) change was justified with the notion that async work would be hoisted up to the route level. The idea of hosting data fetching (and all other async work) has permeated almost every framework via the concept of `loaders`, which require developers literally "hoist" async work to specific functions that can run in parallel. This helps eliminate waterfalls at the cost of code complexity. 

The push towards SSR is part of a larger trend of frameworks focusing on performance. I want to be clear - this isn't a criticism of framework authors, or a suggestion that their focus on performance is misguided. Pursuing performance for the end user - even at the expense of DX - is a noble and justifiable pursuit. But much like dropping into inline assembly can be annoying for a C developer, hoisting async work to loaders, separating server and client code into server and client components, or dealing with dollar-sign hell is annoying for front end developers. 

One of the biggest concerns framework authors have is eliminating waterfalls. If you have a nested component tree where each component fetches data or does some async work before rendering it's children, you end up blocking work that can potentially be done simultaneously. By hoisting this async work to `loaders`, the framework can begin async tasks at the same time. The downside is that you need to somehow tie in async work to URL segments, and collocate your data fetching code with the route itself. The other option - not blocking child rendering - is not explored by any framework, and the concept of suspending rendering is baked into most frameworks. 

Other work has been done to mitigate the cost of client side rendering. Next.js adopted the concept of Server Components - stateless, non-interactive components that are rendered to an intermediatory format on the server to reduce client side computation. This direction has been widely criticised by the React and Next.js communities as being unergonomic, and with debatable performance improvements to boot. This direction has no benefit for client side applications, the main purpose of front end Javascript frameworks. 

This focus on performance and server-side work has exploded the API surface area of JS frameworks. Building an SPA with Vite and Tanstack Query require knowledge of two API's - `useQuery` and `useMutation`. In comparison, Remix has 26 different hooks related to routing and  async state management, Next.js has an insanely convoluted caching API full of footguns, and each framework has their own arcane file-system router filled with special symbols and conventions. Developers are tired of their editors tab-bar filled with `+page.svelte` or `page.ts` files, or magic compilation with non-standard Javascript semantics that make it difficult to understand what their code is actually doing. Developers can't even follow stack traces anymore as the amount of compilation and code transforms results in traces back to internal framework code, not the code they actually wrote. The complexity of building with these frameworks has significantly increased, leaving developers wondering what they have to show for it. 

There is a bright spot however! Astro doubled their usage in 2023 while improving on developer satisfaction and happiness. And Astro is an SSR framework too! It turns out that Javascript developers aren't allergic to the server or SSR - when first-load performance is important, they chose a framework that ships 0 client-side JS by default and allows for a minimal JS payload in the form of islands - pockets of interactivity injected into otherwise static, server rendered HTML. Astro is focused on SSR and static markup, which means its both faster and simpler than other frameworks that try to transform the client-first paradigm into a server-first paradigm. Much of the last few years in JS land has been trying to create a one-size-fits-all paradigm, that can work for content focused ecommerce sites just as well as it can for interaction-heavy client apps. The truth is that the generalist approach cannot be optimal for any specific solution, and the pursuit of such seems to be making developers unhappy.